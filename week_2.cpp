#include <algorithm>
#include <stdio.h>

struct d_t
{
    int x = 0; // предварительная инициализация поля структуры
};

struct vector 
{
    int * first = nullptr;
    size_t length = 0;

    void initialize(const size_t count);
    void print();
};

void printa(const int * array, const size_t count);
bool cmp(const int &a, const int &b);

int main(int argc, char const *argv[])
{
    // статический массив целых чисел
    int a [] = {5, 4, 3, 2, 1};
   
    // https://en.cppreference.com/w/cpp/algorithm/sort
    // стандартный интерфейс для алгоритмов сортировки, принимающих отрезок из ссылок [начало, конец)
    // где "начало" и "конец" - адреса, ограничивающие область памяти, принадлежащую массиву
    std::sort(a, a + 5);

    printa(a, 5); // выводит 1 2 3 4 5, так как по умолчанию массив сортируется по возрастанию

    // аналогичным образом можно отсортировать массив по убыванию, используя функцию сравнения
    // функция должна принимать два аргумента того же типа, как и отдельные элементы массива
    std::sort(a, a + 5, cmp);

    printa(a, 5); // выводит 5 4 3 2 1

    // аналогичным образом можно отсортировать массив структур
    d_t b [] = {{10}, {20}, {30}, {40}, {50}};

    // функция сравнения может быть написана как анонимная
    // для этого всю функцию целиком необходимо включить как параметр,
    // заменив имя функции на квадратные скобки
    // такие функции работают аналогично лямбда-выражениям 
    std::sort(b, b + 5, [] (const d_t & a, const d_t & b) { return a.x > b.x; });

    printa((int *)b, 5); // выводит 50 40 30 20 10

    // для того, чтобы не передавать массив в функции как указатель
    // а также чтобы не хранить его размер отдельно, его можно заключить в структуру
    vector v;

    // аналогично в структуре можно хранить и функции
    v.initialize(5);
    v.print(); // выводит -1 -2 -3 -4 -5
}

void
printa(const int * array, const size_t count)
{
    for (size_t i = 0; i < count; i++)
    {
        printf("%d ", array[i]);
    }
    printf("\n");
}

bool
cmp(const int &a, const int &b)
{
    // согласно документации, для сортировки необходимо, чтобы функция сравнения возвращала true, если
    // a строго меньше b, что приведет к сортировке по возрастанию массива целых чисел, например
    // таким образом, если возвращать отрицание, порядок сортировки изменится на обратный
    return !(a < b);
}

void
vector::initialize(const size_t count)
{
    // выделение памяти для массива в структуре vector (обратите внимание на vector:: перед именем функции)
    // с последующим копированием массива целых чисел в эту область памяти
    first = new int [count] {-1, -2, -3, -4, -5};
    length = count;
}

void
vector::print()
{
    printa(first, length);
}
